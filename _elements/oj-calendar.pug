link(rel="import" href="../lib/bower_components/polymer/polymer.html")
link(rel="import" href="../lib/bower_components/iron-ajax/iron-ajax.html")

dom-module#oj-calendar
	// ---------------------------------------------------------------
	style
		:stylus
			@import '../_lib/css/elements.imports.styl'
			:host
				width: 100%
				color: $oj-violet
				display: flex
				flex-flow: row wrap
				justify-content: space-around
				.cell.header
					font-family: $P
					font-weight: 700
					font-size: 1rem
					letter-spacing: 0.05em
					text-transform: uppercase
					padding: .5rem .5rem .5rem 0
					border-bottom: 1px solid rgba($oj-violet, .4)
				.cell.content
					padding: 1rem .5rem 1rem 0
					border-bottom: 1px solid rgba($oj-violet, .4)
				.cell.when
					flex-basis: 15%
					flex-grow: 1
				.cell.where
					flex-basis: 35%
					flex-grow: 1
				.cell.what
					flex-basis: 50%
					flex-grow: 1
					

	// ---------------------------------------------------------------
	template
		.cell.header.when Kiedy:
		.cell.header.where Gdzie:
		.cell.header.what Co:
		template(is="dom-repeat" items="{{calendarEvents}}")
			.cell.content.when 
				b {{item.when.day}} 
				span {{item.when.weekday}}
			.cell.content.where {{item.where}}
			.cell.content.what {{item.what}}


	// ---------------------------------------------------------------
	script
		:coffee-script
			Polymer
				is: 'oj-calendar'
				properties:
					apiUrl:
						type: String
						value: 'https://www.googleapis.com/calendar/v3/'
					limit: # total limit of events
						type: Number
						value: 10
					apiKey: 
						type: String
					calendarIds: 
						type: Array
					maxResults: #limit per calendar
						type: Number
						value: 20
					showDays: 
						type: Number
						value: 10
					# Computed:
					options:
						type: Object
						computed: 'computeOptions(apiKey, maxResults, showDays)'
					calendarUrls:
						type: String
						computed: 'computeCalendarUrls(apiUrl, calendarIds)'
					# Async:
					calendarEvents:
						type: Array
						value: ->
							return []


				computeCalendarUrls: (apiUrl, calendarIds)->
					return calendarIds.map((calID)->
						return apiUrl + 'calendars/' + calID + '/events'
					)
					
				computeOptions: (apiKey, maxResults, showDays)->
					return {
						key: apiKey
						maxResults: maxResults
						timeMin: moment('2016-01-01T02:07:39+02:00').format()
						timeMax: moment().add(showDays, 'days').format()
						orderBy: 'startTime'
						singleEvents: true
					}

				getEvents: (calendarUrls, options, limit)->
					
					axios.all(
						calendarUrls.map( (url)->
							return axios.get(url, params: options)
						)
					) # AT THIS POINT WE HAVE AN ARRAY OF AXIOS RESPONSES
					.then( (responses)->
						return responses.map( (response)->
							return response.data.items
						)
					) # AT THIS POINT WE HAVE A FULL ARRAY OF CALENDARS
					.then( (calendars)->
						return calendars.reduce( (prev, current)->
							prev.concat(current)
						)
					) # AT THIS POINT WE HAVE AN ARRAY OF EVENTS
					.then( (events)->
						return events.map( (event)->
							dateString = event.start.dateTime or event.start.date
							whendate = moment(dateString).locale('pl')
							return {
								when: 
									day: whendate.format('DD.MM')
									weekday: whendate.format('dd')
								where: event.organizer.displayName
								what: event.summary
							}
						)
					) # AT THIS POINT WE HAVE AN ARRAY OF TRIMMED EVENTS
					.then( (events)->
						return events.sort( (a, b)->
							return (a.when < b.when) ? 1 : (a.when > b.when) ? -1 : 0
						)
					) # AT THIS POINT WE HAVE A TRIMMED ARRAY OF EVENTS, SORTED BY DATE
					.then( (events)->
						return events.slice(0, limit)
					) # AT THIS POINT WE HAVE A TRIMMED ARRAY OF EVENTS, ORDERED BY DATE, LIMITED BY LIMIT
					.then( ((events)->
							this.calendarEvents = events
						).bind(this) # REMEMBER: .bind(this)
					)
					.catch( (error)->
						console.log error
					)
					

				ready: ->
					this.getEvents(this.calendarUrls, this.options, this.limit)
					return
					
				attached: ->
					return

				detached: ->
					return
